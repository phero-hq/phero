// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Parsers for a type alias Generics native generic 1`] = `
"export class MyModelParser {
    static parse<T>(data: any, t0: (data: any) => ParseResult<T>): ParseResult<MyModel<T>> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            {
                const t0_result = t0(data[\\"a\\"]);
                if (!t0_result.ok) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a T\`
                    });
                }
                else
                    result[\\"a\\"] = t0_result.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel<T>
        };
    }
}"
`;

exports[`Parsers for a type alias IndexedAccessTypeNode native member 1`] = `
"export class TreeParser {
    static parse(data: any): ParseResult<Tree> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"aad\\"] !== \\"number\\") {
                errors.push({
                    path: \\"data.aad\\",
                    message: \`not a number\`
                });
            }
            else if (isNaN(data[\\"aad\\"])) {
                errors.push({
                    path: \\"data.aad\\",
                    message: \`invalid number\`
                });
            }
            else
                result[\\"aad\\"] = data[\\"aad\\"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as Tree
        };
    }
}"
`;

exports[`Parsers for a type alias IndexedAccessTypeNode reference member 1`] = `
"export class TreeParser {
    static parse(data: any): ParseResult<Tree> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            {
                const parseResult = BanaanParser.parse(data[\\"aad\\"]);
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.aad\\",
                        message: \`not a Banaan\`
                    });
                }
                else
                    result[\\"aad\\"] = parseResult.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as Tree
        };
    }
}"
`;

exports[`Parsers for a type alias IndexedAccessTypeNode type element member 1`] = `
"export class TreeParser {
    static parse(data: any): ParseResult<Tree> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"aad\\"] !== \\"object\\" || data[\\"aad\\"] === null) {
                errors.push({
                    path: \\"data.aad\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result[\\"aad\\"] = {};
                if (typeof data[\\"aad\\"][\\"kaas\\"] !== \\"number\\") {
                    errors.push({
                        path: \\"data.aad.kaas\\",
                        message: \`not a number\`
                    });
                }
                else if (isNaN(data[\\"aad\\"][\\"kaas\\"])) {
                    errors.push({
                        path: \\"data.aad.kaas\\",
                        message: \`invalid number\`
                    });
                }
                else
                    result[\\"aad\\"][\\"kaas\\"] = data[\\"aad\\"][\\"kaas\\"];
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as Tree
        };
    }
}"
`;

exports[`Parsers for a type alias Reference to another interface 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            {
                const parseResult = AadParser.parse(data[\\"a\\"]);
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a Aad\`
                    });
                }
                else
                    result[\\"a\\"] = parseResult.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias Reference to another interface with a type parameter 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            {
                const parseResult = AadParser.parse<number>(data[\\"a\\"], (data: any): ParseResult<number> => {
                    const errors: ValidationError[] = [];
                    let result: any;
                    if (typeof data !== \\"number\\") {
                        errors.push({
                            path: \\"data\\",
                            message: \`not a number\`
                        });
                    }
                    else if (isNaN(data)) {
                        errors.push({
                            path: \\"data\\",
                            message: \`invalid number\`
                        });
                    }
                    else
                        result = data;
                    if (errors.length) {
                        return {
                            ok: false,
                            errors
                        };
                    }
                    return {
                        ok: true,
                        result: result as number
                    };
                });
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a Aad<number>\`
                    });
                }
                else
                    result[\\"a\\"] = parseResult.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias Reference to another interface with a type parameter with a default 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            {
                const parseResult = AadParser.parse<number>(data[\\"a\\"], (data: any): ParseResult<number> => {
                    const errors: ValidationError[] = [];
                    let result: any;
                    if (typeof data !== \\"number\\") {
                        errors.push({
                            path: \\"data\\",
                            message: \`not a number\`
                        });
                    }
                    else if (isNaN(data)) {
                        errors.push({
                            path: \\"data\\",
                            message: \`invalid number\`
                        });
                    }
                    else
                        result = data;
                    if (errors.length) {
                        return {
                            ok: false,
                            errors
                        };
                    }
                    return {
                        ok: true,
                        result: result as number
                    };
                });
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a Aad<number>\`
                    });
                }
                else
                    result[\\"a\\"] = parseResult.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias Reference to another interface with mixed type parameters 1`] = `
"export class MyModelParser {
    static parse<T, X>(data: any, t0: (data: any) => ParseResult<T>, t1?: (data: any) => ParseResult<X>): ParseResult<MyModel<T, X>> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            {
                const parseResult = AadParser.parse<T>(data[\\"a\\"], t0);
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a Aad<T>\`
                    });
                }
                else
                    result[\\"a\\"] = parseResult.result;
            }
            {
                const parseResult = AadParser.parse<string>(data[\\"b\\"], (data: any): ParseResult<string> => {
                    const errors: ValidationError[] = [];
                    let result: any;
                    if (typeof data !== \\"string\\") {
                        errors.push({
                            path: \\"data\\",
                            message: \`not a string\`
                        });
                    }
                    else
                        result = data;
                    if (errors.length) {
                        return {
                            ok: false,
                            errors
                        };
                    }
                    return {
                        ok: true,
                        result: result as string
                    };
                });
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.b\\",
                        message: \`not a Aad<string>\`
                    });
                }
                else
                    result[\\"b\\"] = parseResult.result;
            }
            {
                const parseResult = AadParser.parse<number>(data[\\"c\\"], (data: any): ParseResult<number> => {
                    const errors: ValidationError[] = [];
                    let result: any;
                    if (typeof data !== \\"number\\") {
                        errors.push({
                            path: \\"data\\",
                            message: \`not a number\`
                        });
                    }
                    else if (isNaN(data)) {
                        errors.push({
                            path: \\"data\\",
                            message: \`invalid number\`
                        });
                    }
                    else
                        result = data;
                    if (errors.length) {
                        return {
                            ok: false,
                            errors
                        };
                    }
                    return {
                        ok: true,
                        result: result as number
                    };
                });
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.c\\",
                        message: \`not a Aad<number>\`
                    });
                }
                else
                    result[\\"c\\"] = parseResult.result;
            }
            {
                const parseResult = AadParser.parse<X>(data[\\"d\\"], t1 ?? ((data: any): ParseResult<X> => {
                    const errors: ValidationError[] = [];
                    let result: any;
                    if (typeof data !== \\"number\\") {
                        errors.push({
                            path: \\"data\\",
                            message: \`not a number\`
                        });
                    }
                    else if (isNaN(data)) {
                        errors.push({
                            path: \\"data\\",
                            message: \`invalid number\`
                        });
                    }
                    else
                        result = data;
                    if (errors.length) {
                        return {
                            ok: false,
                            errors
                        };
                    }
                    return {
                        ok: true,
                        result: result as X
                    };
                }));
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.d\\",
                        message: \`not a Aad<X>\`
                    });
                }
                else
                    result[\\"d\\"] = parseResult.result;
            }
            {
                const parseResult = AadParser.parse(data[\\"e\\"]);
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.e\\",
                        message: \`not a Aad<boolean>\`
                    });
                }
                else
                    result[\\"e\\"] = parseResult.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel<T, X>
        };
    }
}"
`;

exports[`Parsers for a type alias Reference to another interface with own default type parameter 1`] = `
"export class MyModelParser {
    static parse<T>(data: any, t0?: (data: any) => ParseResult<T>): ParseResult<MyModel<T>> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            {
                const parseResult = AadParser.parse<T>(data[\\"a\\"], t0 ?? ((data: any): ParseResult<T> => {
                    const errors: ValidationError[] = [];
                    let result: any;
                    if (typeof data !== \\"number\\") {
                        errors.push({
                            path: \\"data\\",
                            message: \`not a number\`
                        });
                    }
                    else if (isNaN(data)) {
                        errors.push({
                            path: \\"data\\",
                            message: \`invalid number\`
                        });
                    }
                    else
                        result = data;
                    if (errors.length) {
                        return {
                            ok: false,
                            errors
                        };
                    }
                    return {
                        ok: true,
                        result: result as T
                    };
                }));
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a Aad<T>\`
                    });
                }
                else
                    result[\\"a\\"] = parseResult.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel<T>
        };
    }
}"
`;

exports[`Parsers for a type alias Reference to another interface with the default type parameter 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            {
                const parseResult = AadParser.parse(data[\\"a\\"]);
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a Aad<number>\`
                    });
                }
                else
                    result[\\"a\\"] = parseResult.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias index types keyof keys 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            for (let itk_0 = 0, keys = Object.keys(data); itk_0 < keys.length; itk_0++) {
                const it_0 = keys[itk_0];
                if (![\\"aap\\", \\"noot\\"].includes(it_0))
                    continue;
                else if (typeof data[it_0] !== \\"object\\" || data[it_0] === null) {
                    errors.push({
                        path: \`data[\${it_0}]\`,
                        message: \`null or not an object\`
                    });
                }
                else {
                    result[it_0] = {};
                    if (typeof data[it_0][\\"a\\"] !== \\"string\\") {
                        errors.push({
                            path: \`data[\${it_0}].a\`,
                            message: \`not a string\`
                        });
                    }
                    else
                        result[it_0][\\"a\\"] = data[it_0][\\"a\\"];
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias index types number keys 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            for (let itk_0 = 0, keys = Object.keys(data); itk_0 < keys.length; itk_0++) {
                const it_0 = keys[itk_0];
                if (isNaN(parseInt(it_0, 10)))
                    continue;
                else if (typeof data[it_0] !== \\"object\\" || data[it_0] === null) {
                    errors.push({
                        path: \`data[\${it_0}]\`,
                        message: \`null or not an object\`
                    });
                }
                else {
                    result[it_0] = {};
                    if (typeof data[it_0][\\"a\\"] !== \\"string\\") {
                        errors.push({
                            path: \`data[\${it_0}].a\`,
                            message: \`not a string\`
                        });
                    }
                    else
                        result[it_0][\\"a\\"] = data[it_0][\\"a\\"];
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias index types string keys 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            for (let itk_0 = 0, keys = Object.keys(data); itk_0 < keys.length; itk_0++) {
                const it_0 = keys[itk_0];
                if (typeof it_0 !== \\"string\\")
                    continue;
                else if (typeof data[it_0] !== \\"object\\" || data[it_0] === null) {
                    errors.push({
                        path: \`data[\${it_0}]\`,
                        message: \`null or not an object\`
                    });
                }
                else {
                    result[it_0] = {};
                    if (typeof data[it_0][\\"a\\"] !== \\"string\\") {
                        errors.push({
                            path: \`data[\${it_0}].a\`,
                            message: \`not a string\`
                        });
                    }
                    else
                        result[it_0][\\"a\\"] = data[it_0][\\"a\\"];
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias index types union number keys 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            for (let itk_0 = 0, keys = Object.keys(data); itk_0 < keys.length; itk_0++) {
                const it_0 = keys[itk_0];
                if (![10, 20].includes(it_0))
                    continue;
                else if (typeof data[it_0] !== \\"object\\" || data[it_0] === null) {
                    errors.push({
                        path: \`data[\${it_0}]\`,
                        message: \`null or not an object\`
                    });
                }
                else {
                    result[it_0] = {};
                    if (typeof data[it_0][\\"a\\"] !== \\"string\\") {
                        errors.push({
                            path: \`data[\${it_0}].a\`,
                            message: \`not a string\`
                        });
                    }
                    else
                        result[it_0][\\"a\\"] = data[it_0][\\"a\\"];
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias index types union string keys 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            for (let itk_0 = 0, keys = Object.keys(data); itk_0 < keys.length; itk_0++) {
                const it_0 = keys[itk_0];
                if (![\\"aap\\", \\"noot\\"].includes(it_0))
                    continue;
                else if (typeof data[it_0] !== \\"object\\" || data[it_0] === null) {
                    errors.push({
                        path: \`data[\${it_0}]\`,
                        message: \`null or not an object\`
                    });
                }
                else {
                    result[it_0] = {};
                    if (typeof data[it_0][\\"a\\"] !== \\"string\\") {
                        errors.push({
                            path: \`data[\${it_0}].a\`,
                            message: \`not a string\`
                        });
                    }
                    else
                        result[it_0][\\"a\\"] = data[it_0][\\"a\\"];
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias intersection object literal with complex union 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        {
            if (typeof data !== \\"object\\" || data === null) {
                errors.push({
                    path: \\"data\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result = {};
                if (typeof data[\\"a\\"] !== \\"string\\") {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a string\`
                    });
                }
                else
                    result[\\"a\\"] = data[\\"a\\"];
            }
            {
                const errLength = errors.length;
                {
                    if (typeof data !== \\"object\\" || data === null) {
                        errors.push({
                            path: \\"data\\",
                            message: \`null or not an object\`
                        });
                    }
                    else {
                        result = {};
                        if (typeof data[\\"b\\"] !== \\"number\\") {
                            errors.push({
                                path: \\"data.b\\",
                                message: \`not a number\`
                            });
                        }
                        else if (isNaN(data[\\"b\\"])) {
                            errors.push({
                                path: \\"data.b\\",
                                message: \`invalid number\`
                            });
                        }
                        else
                            result[\\"b\\"] = data[\\"b\\"];
                        if (typeof data[\\"c\\"] !== \\"object\\" || data[\\"c\\"] === null) {
                            errors.push({
                                path: \\"data.c\\",
                                message: \`null or not an object\`
                            });
                        }
                        else {
                            result[\\"c\\"] = {};
                            if (data[\\"c\\"][\\"d\\"] !== 123) {
                                errors.push({
                                    path: \\"data.c.d\\",
                                    message: \`not 123\`
                                });
                            }
                            else
                                result[\\"c\\"][\\"d\\"] = data[\\"c\\"][\\"d\\"];
                        }
                    }
                    if (errors.length !== errLength) {
                        errors.splice(errLength, errors.length - errLength);
                        {
                            if (typeof data !== \\"object\\" || data === null) {
                                errors.push({
                                    path: \\"data\\",
                                    message: \`null or not an object\`
                                });
                            }
                            else {
                                result = {};
                                if (typeof data[\\"c\\"] !== \\"boolean\\") {
                                    errors.push({
                                        path: \\"data.c\\",
                                        message: \`not a boolean\`
                                    });
                                }
                                else
                                    result[\\"c\\"] = data[\\"c\\"];
                                if (typeof data[\\"b\\"] !== \\"string\\") {
                                    errors.push({
                                        path: \\"data.b\\",
                                        message: \`not a string\`
                                    });
                                }
                                else
                                    result[\\"b\\"] = data[\\"b\\"];
                            }
                            if (errors.length !== errLength) {
                                errors.splice(errLength, errors.length - errLength);
                                {
                                    errors.push({
                                        path: \\"data\\",
                                        message: \`is none of the options of union\`
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias intersection object literal with union 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        {
            if (typeof data !== \\"object\\" || data === null) {
                errors.push({
                    path: \\"data\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result = {};
                if (typeof data[\\"a\\"] !== \\"string\\") {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a string\`
                    });
                }
                else
                    result[\\"a\\"] = data[\\"a\\"];
            }
            {
                const errLength = errors.length;
                {
                    if (typeof data !== \\"object\\" || data === null) {
                        errors.push({
                            path: \\"data\\",
                            message: \`null or not an object\`
                        });
                    }
                    else {
                        result = {};
                        if (typeof data[\\"b\\"] !== \\"number\\") {
                            errors.push({
                                path: \\"data.b\\",
                                message: \`not a number\`
                            });
                        }
                        else if (isNaN(data[\\"b\\"])) {
                            errors.push({
                                path: \\"data.b\\",
                                message: \`invalid number\`
                            });
                        }
                        else
                            result[\\"b\\"] = data[\\"b\\"];
                    }
                    if (errors.length !== errLength) {
                        errors.splice(errLength, errors.length - errLength);
                        {
                            if (typeof data !== \\"object\\" || data === null) {
                                errors.push({
                                    path: \\"data\\",
                                    message: \`null or not an object\`
                                });
                            }
                            else {
                                result = {};
                                if (typeof data[\\"c\\"] !== \\"boolean\\") {
                                    errors.push({
                                        path: \\"data.c\\",
                                        message: \`not a boolean\`
                                    });
                                }
                                else
                                    result[\\"c\\"] = data[\\"c\\"];
                            }
                            if (errors.length !== errLength) {
                                errors.splice(errLength, errors.length - errLength);
                                {
                                    errors.push({
                                        path: \\"data\\",
                                        message: \`is none of the options of union\`
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias intersection simple 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        {
            if (typeof data !== \\"object\\" || data === null) {
                errors.push({
                    path: \\"data\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result = {};
                if (typeof data[\\"a\\"] !== \\"string\\") {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a string\`
                    });
                }
                else
                    result[\\"a\\"] = data[\\"a\\"];
            }
            if (typeof data !== \\"object\\" || data === null) {
                errors.push({
                    path: \\"data\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result = {};
                if (typeof data[\\"b\\"] !== \\"string\\") {
                    errors.push({
                        path: \\"data.b\\",
                        message: \`not a string\`
                    });
                }
                else
                    result[\\"b\\"] = data[\\"b\\"];
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal boolean array member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (!Array.isArray(data[\\"a\\"])) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not an array\`
                });
            }
            else {
                result[\\"a\\"] = [];
                for (let it_0 = 0; it_0 < data[\\"a\\"].length; it_0++)
                    if (typeof data[\\"a\\"][it_0] !== \\"boolean\\") {
                        errors.push({
                            path: \`data.a[\${it_0}]\`,
                            message: \`not a boolean\`
                        });
                    }
                    else
                        result[\\"a\\"][it_0] = data[\\"a\\"][it_0];
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal boolean member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"a\\"] !== \\"boolean\\") {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not a boolean\`
                });
            }
            else
                result[\\"a\\"] = data[\\"a\\"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal deep nested object 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"a\\"] !== \\"object\\" || data[\\"a\\"] === null) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result[\\"a\\"] = {};
                if (data[\\"a\\"][\\"b\\"] !== undefined)
                    if (!Array.isArray(data[\\"a\\"][\\"b\\"])) {
                        errors.push({
                            path: \\"data.a.b\\",
                            message: \`not an array\`
                        });
                    }
                    else {
                        result[\\"a\\"][\\"b\\"] = [];
                        for (let it_0 = 0; it_0 < data[\\"a\\"][\\"b\\"].length; it_0++)
                            if (typeof data[\\"a\\"][\\"b\\"][it_0] !== \\"object\\" || data[\\"a\\"][\\"b\\"][it_0] === null) {
                                errors.push({
                                    path: \`data.a.b[\${it_0}]\`,
                                    message: \`null or not an object\`
                                });
                            }
                            else {
                                result[\\"a\\"][\\"b\\"][it_0] = {};
                                if (typeof data[\\"a\\"][\\"b\\"][it_0][\\"c\\"] !== \\"object\\" || data[\\"a\\"][\\"b\\"][it_0][\\"c\\"] === null) {
                                    errors.push({
                                        path: \`data.a.b[\${it_0}].c\`,
                                        message: \`null or not an object\`
                                    });
                                }
                                else {
                                    result[\\"a\\"][\\"b\\"][it_0][\\"c\\"] = {};
                                    if (data[\\"a\\"][\\"b\\"][it_0][\\"c\\"][\\"d\\"] !== undefined)
                                        if (typeof data[\\"a\\"][\\"b\\"][it_0][\\"c\\"][\\"d\\"] !== \\"number\\") {
                                            errors.push({
                                                path: \`data.a.b[\${it_0}].c.d\`,
                                                message: \`not a number\`
                                            });
                                        }
                                        else if (isNaN(data[\\"a\\"][\\"b\\"][it_0][\\"c\\"][\\"d\\"])) {
                                            errors.push({
                                                path: \`data.a.b[\${it_0}].c.d\`,
                                                message: \`invalid number\`
                                            });
                                        }
                                        else
                                            result[\\"a\\"][\\"b\\"][it_0][\\"c\\"][\\"d\\"] = data[\\"a\\"][\\"b\\"][it_0][\\"c\\"][\\"d\\"];
                                }
                            }
                    }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal null member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"a\\"] !== null) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not null\`
                });
            }
            else
                result[\\"a\\"] = data[\\"a\\"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal number array member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (!Array.isArray(data[\\"a\\"])) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not an array\`
                });
            }
            else {
                result[\\"a\\"] = [];
                for (let it_0 = 0; it_0 < data[\\"a\\"].length; it_0++)
                    if (typeof data[\\"a\\"][it_0] !== \\"number\\") {
                        errors.push({
                            path: \`data.a[\${it_0}]\`,
                            message: \`not a number\`
                        });
                    }
                    else if (isNaN(data[\\"a\\"][it_0])) {
                        errors.push({
                            path: \`data.a[\${it_0}]\`,
                            message: \`invalid number\`
                        });
                    }
                    else
                        result[\\"a\\"][it_0] = data[\\"a\\"][it_0];
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal number literal member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (data[\\"a\\"] !== 123) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not 123\`
                });
            }
            else
                result[\\"a\\"] = data[\\"a\\"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal number member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"a\\"] !== \\"number\\") {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not a number\`
                });
            }
            else if (isNaN(data[\\"a\\"])) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`invalid number\`
                });
            }
            else
                result[\\"a\\"] = data[\\"a\\"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal number model 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"number\\") {
            errors.push({
                path: \\"data\\",
                message: \`not a number\`
            });
        }
        else if (isNaN(data)) {
            errors.push({
                path: \\"data\\",
                message: \`invalid number\`
            });
        }
        else
            result = data;
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal object literal member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (!Array.isArray(data[\\"a\\"])) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not an array\`
                });
            }
            else {
                result[\\"a\\"] = [];
                for (let it_0 = 0; it_0 < data[\\"a\\"].length; it_0++)
                    if (typeof data[\\"a\\"][it_0] !== \\"object\\" || data[\\"a\\"][it_0] === null) {
                        errors.push({
                            path: \`data.a[\${it_0}]\`,
                            message: \`null or not an object\`
                        });
                    }
                    else {
                        result[\\"a\\"][it_0] = {};
                        if (typeof data[\\"a\\"][it_0][\\"b\\"] !== \\"number\\") {
                            errors.push({
                                path: \`data.a[\${it_0}].b\`,
                                message: \`not a number\`
                            });
                        }
                        else if (isNaN(data[\\"a\\"][it_0][\\"b\\"])) {
                            errors.push({
                                path: \`data.a[\${it_0}].b\`,
                                message: \`invalid number\`
                            });
                        }
                        else
                            result[\\"a\\"][it_0][\\"b\\"] = data[\\"a\\"][it_0][\\"b\\"];
                    }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal optional member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (data[\\"a\\"] !== undefined)
                if (typeof data[\\"a\\"] !== \\"string\\") {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not a string\`
                    });
                }
                else
                    result[\\"a\\"] = data[\\"a\\"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal optional object literal member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (data[\\"a\\"] !== undefined)
                if (!Array.isArray(data[\\"a\\"])) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not an array\`
                    });
                }
                else {
                    result[\\"a\\"] = [];
                    for (let it_0 = 0; it_0 < data[\\"a\\"].length; it_0++)
                        if (typeof data[\\"a\\"][it_0] !== \\"object\\" || data[\\"a\\"][it_0] === null) {
                            errors.push({
                                path: \`data.a[\${it_0}]\`,
                                message: \`null or not an object\`
                            });
                        }
                        else {
                            result[\\"a\\"][it_0] = {};
                            if (typeof data[\\"a\\"][it_0][\\"b\\"] !== \\"number\\") {
                                errors.push({
                                    path: \`data.a[\${it_0}].b\`,
                                    message: \`not a number\`
                                });
                            }
                            else if (isNaN(data[\\"a\\"][it_0][\\"b\\"])) {
                                errors.push({
                                    path: \`data.a[\${it_0}].b\`,
                                    message: \`invalid number\`
                                });
                            }
                            else
                                result[\\"a\\"][it_0][\\"b\\"] = data[\\"a\\"][it_0][\\"b\\"];
                        }
                }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal optional object literal with optional member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (data[\\"a\\"] !== undefined)
                if (typeof data[\\"a\\"] !== \\"object\\" || data[\\"a\\"] === null) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`null or not an object\`
                    });
                }
                else {
                    result[\\"a\\"] = {};
                    if (data[\\"a\\"][\\"b\\"] !== undefined)
                        if (typeof data[\\"a\\"][\\"b\\"] !== \\"number\\") {
                            errors.push({
                                path: \\"data.a.b\\",
                                message: \`not a number\`
                            });
                        }
                        else if (isNaN(data[\\"a\\"][\\"b\\"])) {
                            errors.push({
                                path: \\"data.a.b\\",
                                message: \`invalid number\`
                            });
                        }
                        else
                            result[\\"a\\"][\\"b\\"] = data[\\"a\\"][\\"b\\"];
                }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal optional string array member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (data[\\"a\\"] !== undefined)
                if (!Array.isArray(data[\\"a\\"])) {
                    errors.push({
                        path: \\"data.a\\",
                        message: \`not an array\`
                    });
                }
                else {
                    result[\\"a\\"] = [];
                    for (let it_0 = 0; it_0 < data[\\"a\\"].length; it_0++)
                        if (typeof data[\\"a\\"][it_0] !== \\"string\\") {
                            errors.push({
                                path: \`data.a[\${it_0}]\`,
                                message: \`not a string\`
                            });
                        }
                        else
                            result[\\"a\\"][it_0] = data[\\"a\\"][it_0];
                }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal string array member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (!Array.isArray(data[\\"a\\"])) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not an array\`
                });
            }
            else {
                result[\\"a\\"] = [];
                for (let it_0 = 0; it_0 < data[\\"a\\"].length; it_0++)
                    if (typeof data[\\"a\\"][it_0] !== \\"string\\") {
                        errors.push({
                            path: \`data.a[\${it_0}]\`,
                            message: \`not a string\`
                        });
                    }
                    else
                        result[\\"a\\"][it_0] = data[\\"a\\"][it_0];
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal string literal member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (data[\\"a\\"] !== \\"xxx\\") {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not 'xxx'\`
                });
            }
            else
                result[\\"a\\"] = data[\\"a\\"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal string member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"a\\"] !== \\"string\\") {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not a string\`
                });
            }
            else
                result[\\"a\\"] = data[\\"a\\"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal true literal member 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (data[\\"a\\"] !== true) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`not true\`
                });
            }
            else
                result[\\"a\\"] = data[\\"a\\"];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias object literal with no members 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias recursive types Tree 1`] = `
"export class NumberTreeParser {
    static parse(data: any): ParseResult<NumberTree> {
        const errors: ValidationError[] = [];
        let result: any;
        {
            const parseResult = NumberTreeParser.parse<number>(data, (data: any): ParseResult<number> => {
                const errors: ValidationError[] = [];
                let result: any;
                if (typeof data !== \\"number\\") {
                    errors.push({
                        path: \\"data\\",
                        message: \`not a number\`
                    });
                }
                else if (isNaN(data)) {
                    errors.push({
                        path: \\"data\\",
                        message: \`invalid number\`
                    });
                }
                else
                    result = data;
                if (errors.length) {
                    return {
                        ok: false,
                        errors
                    };
                }
                return {
                    ok: true,
                    result: result as number
                };
            });
            if (!parseResult.ok) {
                errors.push({
                    path: \\"data\\",
                    message: \`not a NumberTree\`
                });
            }
            else
                result = parseResult.result;
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as NumberTree
        };
    }
}"
`;

exports[`Parsers for a type alias recursive types Tree 2`] = `
"export class TreeParser {
    static parse<T>(data: any, t0: (data: any) => ParseResult<T>): ParseResult<Tree<T>> {
        const errors: ValidationError[] = [];
        let result: any;
        {
            const errLength = errors.length;
            {
                {
                    const parseResult = LeafParser.parse<T>(data, t0);
                    if (!parseResult.ok) {
                        errors.push({
                            path: \\"data\\",
                            message: \`not a Leaf<T>\`
                        });
                    }
                    else
                        result = parseResult.result;
                }
                if (errors.length !== errLength) {
                    errors.splice(errLength, errors.length - errLength);
                    {
                        {
                            const parseResult = BranchParser.parse<T>(data, t0);
                            if (!parseResult.ok) {
                                errors.push({
                                    path: \\"data\\",
                                    message: \`not a Branch<T>\`
                                });
                            }
                            else
                                result = parseResult.result;
                        }
                        if (errors.length !== errLength) {
                            errors.splice(errLength, errors.length - errLength);
                            {
                                errors.push({
                                    path: \\"data\\",
                                    message: \`is none of the options of union\`
                                });
                            }
                        }
                    }
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as Tree<T>
        };
    }
}"
`;

exports[`Parsers for a type alias recursive types Tree 3`] = `
"export class LeafParser {
    static parse<A>(data: any, t0: (data: any) => ParseResult<A>): ParseResult<Leaf<A>> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (data[\\"type\\"] !== \\"leaf\\") {
                errors.push({
                    path: \\"data.type\\",
                    message: \`not 'leaf'\`
                });
            }
            else
                result[\\"type\\"] = data[\\"type\\"];
            {
                const t0_result = t0(data[\\"value\\"]);
                if (!t0_result.ok) {
                    errors.push({
                        path: \\"data.value\\",
                        message: \`not a A\`
                    });
                }
                else
                    result[\\"value\\"] = t0_result.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as Leaf<A>
        };
    }
}"
`;

exports[`Parsers for a type alias recursive types Tree 4`] = `
"export class BranchParser {
    static parse<A>(data: any, t0: (data: any) => ParseResult<A>): ParseResult<Branch<A>> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (data[\\"type\\"] !== \\"branch\\") {
                errors.push({
                    path: \\"data.type\\",
                    message: \`not 'branch'\`
                });
            }
            else
                result[\\"type\\"] = data[\\"type\\"];
            {
                const parseResult = TreeParser.parse<A>(data[\\"left\\"], t0);
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.left\\",
                        message: \`not a Tree<A>\`
                    });
                }
                else
                    result[\\"left\\"] = parseResult.result;
            }
            {
                const parseResult = TreeParser.parse<A>(data[\\"right\\"], t0);
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.right\\",
                        message: \`not a Tree<A>\`
                    });
                }
                else
                    result[\\"right\\"] = parseResult.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as Branch<A>
        };
    }
}"
`;

exports[`Parsers for a type alias recursive types simple 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"prop1\\"] !== \\"number\\") {
                errors.push({
                    path: \\"data.prop1\\",
                    message: \`not a number\`
                });
            }
            else if (isNaN(data[\\"prop1\\"])) {
                errors.push({
                    path: \\"data.prop1\\",
                    message: \`invalid number\`
                });
            }
            else
                result[\\"prop1\\"] = data[\\"prop1\\"];
            if (data[\\"prop2\\"] !== undefined) {
                const parseResult = MyModelParser.parse(data[\\"prop2\\"]);
                if (!parseResult.ok) {
                    errors.push({
                        path: \\"data.prop2\\",
                        message: \`not a MyModel\`
                    });
                }
                else
                    result[\\"prop2\\"] = parseResult.result;
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias tuple simple 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (!Array.isArray(data) || data.length !== 2) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = [];
            if (typeof data[0] !== \\"string\\") {
                errors.push({
                    path: \\"data[0]\\",
                    message: \`not a string\`
                });
            }
            else
                result[0] = data[0];
            if (typeof data[1] !== \\"number\\") {
                errors.push({
                    path: \\"data[1]\\",
                    message: \`not a number\`
                });
            }
            else if (isNaN(data[1])) {
                errors.push({
                    path: \\"data[1]\\",
                    message: \`invalid number\`
                });
            }
            else
                result[1] = data[1];
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias tuple tuple with typealias 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (!Array.isArray(data) || data.length !== 2) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = [];
            if (typeof data[0] !== \\"string\\") {
                errors.push({
                    path: \\"data[0]\\",
                    message: \`not a string\`
                });
            }
            else
                result[0] = data[0];
            if (typeof data[1] !== \\"object\\" || data[1] === null) {
                errors.push({
                    path: \\"data[1]\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result[1] = {};
                if (typeof data[1][\\"a\\"] !== \\"number\\") {
                    errors.push({
                        path: \\"data[1].a\\",
                        message: \`not a number\`
                    });
                }
                else if (isNaN(data[1][\\"a\\"])) {
                    errors.push({
                        path: \\"data[1].a\\",
                        message: \`invalid number\`
                    });
                }
                else
                    result[1][\\"a\\"] = data[1][\\"a\\"];
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias tuple tuple within tuple 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (!Array.isArray(data) || data.length !== 2) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = [];
            if (typeof data[0] !== \\"string\\") {
                errors.push({
                    path: \\"data[0]\\",
                    message: \`not a string\`
                });
            }
            else
                result[0] = data[0];
            if (!Array.isArray(data[1]) || data[1].length !== 2) {
                errors.push({
                    path: \\"data[1]\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result[1] = [];
                if (typeof data[1][0] !== \\"object\\" || data[1][0] === null) {
                    errors.push({
                        path: \\"data[1][0]\\",
                        message: \`null or not an object\`
                    });
                }
                else {
                    result[1][0] = {};
                    if (typeof data[1][0][\\"a\\"] !== \\"number\\") {
                        errors.push({
                            path: \\"data[1][0].a\\",
                            message: \`not a number\`
                        });
                    }
                    else if (isNaN(data[1][0][\\"a\\"])) {
                        errors.push({
                            path: \\"data[1][0].a\\",
                            message: \`invalid number\`
                        });
                    }
                    else
                        result[1][0][\\"a\\"] = data[1][0][\\"a\\"];
                }
                if (typeof data[1][1] !== \\"boolean\\") {
                    errors.push({
                        path: \\"data[1][1]\\",
                        message: \`not a boolean\`
                    });
                }
                else
                    result[1][1] = data[1][1];
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias typescript utility types Omit 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"a\\"] !== \\"object\\" || data[\\"a\\"] === null) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result[\\"a\\"] = {};
                if (typeof data[\\"a\\"][\\"kees\\"] !== \\"object\\" || data[\\"a\\"][\\"kees\\"] === null) {
                    errors.push({
                        path: \\"data.a.kees\\",
                        message: \`null or not an object\`
                    });
                }
                else {
                    result[\\"a\\"][\\"kees\\"] = {};
                    if (typeof data[\\"a\\"][\\"kees\\"][\\"a\\"] !== \\"number\\") {
                        errors.push({
                            path: \\"data.a.kees.a\\",
                            message: \`not a number\`
                        });
                    }
                    else if (isNaN(data[\\"a\\"][\\"kees\\"][\\"a\\"])) {
                        errors.push({
                            path: \\"data.a.kees.a\\",
                            message: \`invalid number\`
                        });
                    }
                    else
                        result[\\"a\\"][\\"kees\\"][\\"a\\"] = data[\\"a\\"][\\"kees\\"][\\"a\\"];
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias typescript utility types Pick 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        if (typeof data !== \\"object\\" || data === null) {
            errors.push({
                path: \\"data\\",
                message: \`null or not an object\`
            });
        }
        else {
            result = {};
            if (typeof data[\\"a\\"] !== \\"object\\" || data[\\"a\\"] === null) {
                errors.push({
                    path: \\"data.a\\",
                    message: \`null or not an object\`
                });
            }
            else {
                result[\\"a\\"] = {};
                if (typeof data[\\"a\\"][\\"b\\"] !== \\"boolean\\") {
                    errors.push({
                        path: \\"data.a.b\\",
                        message: \`not a boolean\`
                    });
                }
                else
                    result[\\"a\\"][\\"b\\"] = data[\\"a\\"][\\"b\\"];
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias union simple 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        {
            const errLength = errors.length;
            {
                if (typeof data !== \\"string\\") {
                    errors.push({
                        path: \\"data\\",
                        message: \`not a string\`
                    });
                }
                else
                    result = data;
                if (errors.length !== errLength) {
                    errors.splice(errLength, errors.length - errLength);
                    {
                        if (typeof data !== \\"number\\") {
                            errors.push({
                                path: \\"data\\",
                                message: \`not a number\`
                            });
                        }
                        else if (isNaN(data)) {
                            errors.push({
                                path: \\"data\\",
                                message: \`invalid number\`
                            });
                        }
                        else
                            result = data;
                        if (errors.length !== errLength) {
                            errors.splice(errLength, errors.length - errLength);
                            {
                                errors.push({
                                    path: \\"data\\",
                                    message: \`is none of the options of union\`
                                });
                            }
                        }
                    }
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias union with tuple 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        {
            const errLength = errors.length;
            {
                if (typeof data !== \\"string\\") {
                    errors.push({
                        path: \\"data\\",
                        message: \`not a string\`
                    });
                }
                else
                    result = data;
                if (errors.length !== errLength) {
                    errors.splice(errLength, errors.length - errLength);
                    {
                        if (!Array.isArray(data) || data.length !== 2) {
                            errors.push({
                                path: \\"data\\",
                                message: \`null or not an object\`
                            });
                        }
                        else {
                            result = [];
                            if (typeof data[0] !== \\"object\\" || data[0] === null) {
                                errors.push({
                                    path: \\"data[0]\\",
                                    message: \`null or not an object\`
                                });
                            }
                            else {
                                result[0] = {};
                                if (typeof data[0][\\"a\\"] !== \\"number\\") {
                                    errors.push({
                                        path: \\"data[0].a\\",
                                        message: \`not a number\`
                                    });
                                }
                                else if (isNaN(data[0][\\"a\\"])) {
                                    errors.push({
                                        path: \\"data[0].a\\",
                                        message: \`invalid number\`
                                    });
                                }
                                else
                                    result[0][\\"a\\"] = data[0][\\"a\\"];
                            }
                            if (typeof data[1] !== \\"string\\") {
                                errors.push({
                                    path: \\"data[1]\\",
                                    message: \`not a string\`
                                });
                            }
                            else
                                result[1] = data[1];
                        }
                        if (errors.length !== errLength) {
                            errors.splice(errLength, errors.length - errLength);
                            {
                                errors.push({
                                    path: \\"data\\",
                                    message: \`is none of the options of union\`
                                });
                            }
                        }
                    }
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias union with tuple 2`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        {
            const errLength = errors.length;
            {
                if (typeof data !== \\"object\\" || data === null) {
                    errors.push({
                        path: \\"data\\",
                        message: \`null or not an object\`
                    });
                }
                else {
                    result = {};
                    if (typeof data[\\"a\\"] !== \\"string\\") {
                        errors.push({
                            path: \\"data.a\\",
                            message: \`not a string\`
                        });
                    }
                    else
                        result[\\"a\\"] = data[\\"a\\"];
                    if (typeof data[\\"b\\"] !== \\"number\\") {
                        errors.push({
                            path: \\"data.b\\",
                            message: \`not a number\`
                        });
                    }
                    else if (isNaN(data[\\"b\\"])) {
                        errors.push({
                            path: \\"data.b\\",
                            message: \`invalid number\`
                        });
                    }
                    else
                        result[\\"b\\"] = data[\\"b\\"];
                }
                if (errors.length !== errLength) {
                    errors.splice(errLength, errors.length - errLength);
                    {
                        if (typeof data !== \\"object\\" || data === null) {
                            errors.push({
                                path: \\"data\\",
                                message: \`null or not an object\`
                            });
                        }
                        else {
                            result = {};
                            if (typeof data[\\"a\\"] !== \\"number\\") {
                                errors.push({
                                    path: \\"data.a\\",
                                    message: \`not a number\`
                                });
                            }
                            else if (isNaN(data[\\"a\\"])) {
                                errors.push({
                                    path: \\"data.a\\",
                                    message: \`invalid number\`
                                });
                            }
                            else
                                result[\\"a\\"] = data[\\"a\\"];
                            if (typeof data[\\"b\\"] !== \\"string\\") {
                                errors.push({
                                    path: \\"data.b\\",
                                    message: \`not a string\`
                                });
                            }
                            else
                                result[\\"b\\"] = data[\\"b\\"];
                        }
                        if (errors.length !== errLength) {
                            errors.splice(errLength, errors.length - errLength);
                            {
                                errors.push({
                                    path: \\"data\\",
                                    message: \`is none of the options of union\`
                                });
                            }
                        }
                    }
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;

exports[`Parsers for a type alias union with type literal 1`] = `
"export class MyModelParser {
    static parse(data: any): ParseResult<MyModel> {
        const errors: ValidationError[] = [];
        let result: any;
        {
            const errLength = errors.length;
            {
                if (typeof data !== \\"string\\") {
                    errors.push({
                        path: \\"data\\",
                        message: \`not a string\`
                    });
                }
                else
                    result = data;
                if (errors.length !== errLength) {
                    errors.splice(errLength, errors.length - errLength);
                    {
                        if (typeof data !== \\"object\\" || data === null) {
                            errors.push({
                                path: \\"data\\",
                                message: \`null or not an object\`
                            });
                        }
                        else {
                            result = {};
                            if (typeof data[\\"a\\"] !== \\"number\\") {
                                errors.push({
                                    path: \\"data.a\\",
                                    message: \`not a number\`
                                });
                            }
                            else if (isNaN(data[\\"a\\"])) {
                                errors.push({
                                    path: \\"data.a\\",
                                    message: \`invalid number\`
                                });
                            }
                            else
                                result[\\"a\\"] = data[\\"a\\"];
                        }
                        if (errors.length !== errLength) {
                            errors.splice(errLength, errors.length - errLength);
                            {
                                errors.push({
                                    path: \\"data\\",
                                    message: \`is none of the options of union\`
                                });
                            }
                        }
                    }
                }
            }
        }
        if (errors.length) {
            return {
                ok: false,
                errors
            };
        }
        return {
            ok: true,
            result: result as MyModel
        };
    }
}"
`;
