# Samen

A backend framework for API's based on RPC. Minimal, fast and with autogenerated clients for your front-ends.

## Introduction

Samen is a backend framework for typescript developers to build API's.

The name **samen** means **together** in Dutch and it's how we envision building apps. The frontend and backend
not as isolated containers but as two parts working together.

By using Samen, building API's and sharing models between the client and API, is only a matter of writing functions and importing these
in the frontend.

- API's as functions
- Live autogenerated Samen Client
- Domain models sharing between API and frontend
- Using API's as functions in the client
- Middleware
- Error handling
- Typescript
- Build for your own infra

## Quick Example

`api/samen.ts`

```ts
import { myDBClient } from "./db.ts"

export interface User {
  id: string
  name: string
}

export async function getUser(id: string): Promise<User> {
  return await myDBClient.getUser(id)
}
```

`web/User.tsx`

```ts
import { useState } from "react"
import { SamenClient, User } from "@samen/client"

const samen = new SamenClient()

export default function User(props: { userId: string }) {
  const [user, setUser] = useState<User>()

  const getData = useCallback(async () => {
    const user = await samen.getUser(userId)
    setUser(user)
  }, [userId])

  useEffect(() => getData(), [getData])

  if (!user) {
    return <div>Loading user...</div>
  }

  return <div>Welcome {user.name}!</div>
}
```

In this example we expose a `User` interface and a `getUser` function from our API.
Then within our frontend app, we can import and user the `User` model and the `SamenClient` directly from the `@samen/client` package which is autogenerated and live updated.

That's all it takes to build API's and share domain models between backend and frontend!

### Installation

```
$ npm i samen
```

or

```
$ yarn add samen
```

### Usage

Let's say we have React web project project with the following folder structure:

```
myApp
 \ api
 \ web
```

We can then define our backend service as:

`myApp/api/samen.ts`

```ts
export interface User {
  id: string
  name: string
  lastName: string
}

export default function getUser(id: string) {
  return await myDatabase.getUser(id)
}
```

And then in our client we can user our backend function as:

`myApp/web/samen.ts`

```ts
import { User } from "@samen/client"
export const samen = new SamenClient()
```

`myApp/web/User.tsx`

```ts
import { User } from "@samen/client"
import { samen } from "./samen"

export default function User(props: { userId: string }) {
  const [user, setUser] = useState<User>()

  useEffect(() => {
    samen.getUser(userId).then((result) => {
      setUser(result)
    })
  }, [])

  if (!user) {
    return <div>No user</div>
  }

  return (
    <div>
      Welcome {user.name} {user.lastName}
    </div>
  )
}
```

Then run in your api folder:
`$ npm run samen serve`

and in your client:
`$ npm run samen watch`

## Features

- Code-first
- Declarative
- End-to-end typesafe
- Middleware
- Errorhandling
- Autoupdate

## Credits

Built with ♥️ by [Press Play](https://pressplay.dev)
